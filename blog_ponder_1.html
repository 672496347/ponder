<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>ponder: Ponder 1.x Release Notes</title>
<link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Slab|Ubuntu+Mono" rel="stylesheet">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox_style.css" rel="stylesheet" type="text/css"/>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-3400898-6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-3400898-6');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectalign">
   <div id="projectname">ponder
   <span id="projectnumber">3.1</span>
   </div>
   <div id="projectbrief">C++ reflection library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('blog_ponder_1.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ponder 1.x Release Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ponder_1_0">1.0 Release Notes</a></li>
<li class="level1"><a href="#ponder_1_1">1.1 Release Notes</a><ul><li class="level2"><a href="#placement_new">Placement new creation of objects added</a></li>
<li class="level2"><a href="#undeclare">Ability to undeclare Classes and Enums</a></li>
<li class="level2"><a href="#member_iterators">Class function and property iterators added</a></li>
<li class="level2"><a href="#access_by_index">UserObject function and property access by index added</a></li>
<li class="level2"><a href="#internal_dict">Dictionaries</a></li>
</ul>
</li>
<li class="level1"><a href="#ponder_1_2">1.2 Release Notes</a><ul><li class="level2"><a href="#prop_chaining">Properties support method chaining</a></li>
<li class="level2"><a href="#userobj_pointers">UserObjects can be created from user pointers</a></li>
<li class="level2"><a href="#remove_composed">Remove composed function bindings</a></li>
<li class="level2"><a href="#enum_type">ponder::Type now an enum class</a></li>
<li class="level2"><a href="#unittests_readded">Unit tests</a></li>
</ul>
</li>
<li class="level1"><a href="#ponder_1_3">1.3 Release Notes</a><ul><li class="level2"><a href="#id_traits">Ids/Names configurable using traits</a></li>
<li class="level2"><a href="#string_view_added">string_view class added</a></li>
<li class="level2"><a href="#lambda_added">Lambda functions recognised</a></li>
<li class="level2"><a href="#auto_ptr_removed">std::auto_ptr removed</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>These a notes for an older API <em>for reference</em>. The details may have changed and therefore the links and code may not work. Make sure you check the latest docs.</dd></dl>
<h1><a class="anchor" id="ponder_1_0"></a>
1.0 Release Notes</h1>
<p><em>date: 2016-01-01 20:46:12</em></p>
<dl class="section user"><dt>ponder: to reflect on</dt><dd></dd></dl>
<p>Ponder is a fork of <a href="https://github.com/tegesoft/camp">CAMP</a>, which reached the end of its life. Ponder 1.0 keeps the same API as CAMP, but makes some changes, like removing the Boost dependency, instead using C++11 features. Boost is great library, but more recent C++ changes supply a lot of this functionality in the language and standard libraries.</p>
<p>CAMP was originally released, by <a href="http://www.tegesoft.com/">Tegesoft</a>, under the LGPL licence, but this changed to the MIT licence in version 0.8. Ponder retains the same licence. </p><pre class="fragment">Copyright (C) 2009-2014 TEGESO/TEGESOFT and/or its subsidiary(-ies) and mother company.
Contact: Tegesoft Information (contact@tegesoft.com)

This file is part of the CAMP library.

The MIT License (MIT)

Copyright (C) 2009-2014 TEGESO/TEGESOFT and/or its subsidiary(-ies) and mother company.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</pre><h1><a class="anchor" id="ponder_1_1"></a>
1.1 Release Notes</h1>
<p><em>date: 2016-05-16</em></p>
<h2><a class="anchor" id="placement_new"></a>
Placement new creation of objects added</h2>
<p>You can now use placement new to specify the location of a class instance. This is useful if you are managing your own memory.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classponder_1_1_class.html">ponder::Class</a>* metaclass = &amp;ponder::classByType&lt;MyClass&gt;();</div><div class="line"><span class="keyword">const</span> std::size_t sz = metaclass-&gt;<a class="code" href="classponder_1_1_class.html#ac14fcdb69ea4a0443754f2559fb95fd4">sizeOf</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* p = malloc(<span class="keyword">sizeof</span>(sz))</div><div class="line"></div><div class="line"><span class="comment">// note extra argument here:</span></div><div class="line"><a class="code" href="classponder_1_1_user_object.html">ponder::UserObject</a> <span class="keywordtype">object</span> = metaclass-&gt;construct(<a class="code" href="classponder_1_1_args.html">ponder::Args</a>(), p);</div><div class="line"></div><div class="line">MyClass* instance = <span class="keywordtype">object</span>.get&lt;MyClass*&gt;();</div><div class="line"></div><div class="line">assert(instance == reinterpret_cast&lt;MyClass*&gt;(p));</div><div class="line"></div><div class="line"><span class="comment">// Be sure to destruct the object as destroy calls delete.</span></div><div class="line">metaclass-&gt;<a class="code" href="classponder_1_1_class.html#a0c15472ae0ae7944475ec202c36c67ab">destruct</a>(<span class="keywordtype">object</span>); <span class="comment">// not destroy()</span></div><div class="line">free(p);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is now a <code>Class::destruct()</code> to pair with placement new.</dd></dl>
<h2><a class="anchor" id="undeclare"></a>
Ability to undeclare Classes and Enums</h2>
<p>Classes and Enums can be undeclared. This is useful if you need to unload classes which you will no longer need. E.g. when unloading dynamic libraries which contain Ponder registered objects.</p>
<p>Be careful not to auto register the class declarations or they will be added straight back again!</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> declare_types()  <span class="comment">// call manually to declare</span></div><div class="line">{</div><div class="line">    ponder::Class::declare&lt;MyClass&gt;()</div><div class="line">        <span class="comment">// ... members</span></div><div class="line">        ;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> undeclare_types()  <span class="comment">// call manually to undeclare</span></div><div class="line">{</div><div class="line">    <a class="code" href="classponder_1_1_class.html#a7a72a91f3dba2118083a17dfa76fb1ad">ponder::Class::undeclare</a>(ponder::classByType&lt;MyClass&gt;());</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="pondertype_8hpp.html#aee5005c7943f3506b239d987821d5486">PONDER_TYPE</a>(MyClass);  <span class="comment">// not PONDER_AUTO_TYPE()</span></div></div><!-- fragment --><h2><a class="anchor" id="member_iterators"></a>
Class function and property iterators added</h2>
<p>Properties and functions are easier to iterate over:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; prop : metaclass.<a class="code" href="classponder_1_1_class.html#a2a5126a7f0f3483c79438348649c2f31">propertyIterator</a>()) {}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; func : metaclass.<a class="code" href="classponder_1_1_class.html#abd16f3f9de5a45519a51b08051670ffa">functionIterator</a>()) {}</div></div><!-- fragment --><h2><a class="anchor" id="access_by_index"></a>
UserObject function and property access by index added</h2>
<p>In addition to by name and functions and properties in UserObjects can be accessed by index:</p>
<div class="fragment"><div class="line">MyClass object(3);</div><div class="line"><a class="code" href="classponder_1_1_user_object.html">ponder::UserObject</a> userObject(<span class="keywordtype">object</span>);</div><div class="line">userObject.get(0);</div><div class="line">userObject.set(1, 7);</div></div><!-- fragment --><h2><a class="anchor" id="internal_dict"></a>
Dictionaries</h2>
<p>Dictionaries are now ordered (sorted alphabetically) internally. The insertion cost will be more, but this will only happen on declaration. Searching for keys will become a binary search rather than linear.</p>
<h1><a class="anchor" id="ponder_1_2"></a>
1.2 Release Notes</h1>
<p><em>date: 2016-07-01</em></p>
<h2><a class="anchor" id="prop_chaining"></a>
Properties support method chaining</h2>
<p>Ponder now recognises if properties return the class they are declared in. This allows <a href="https://en.wikipedia.org/wiki/Method_chaining">method chaining</a>. This is also called the "named parameter idiom", see <a href="https://github.com/billyquith/ponder/issues/28">issue #28</a>. E.g.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> Getter() { <span class="keywordflow">return</span> i_; };</div><div class="line">    MyClass&amp; Setter(<span class="keywordtype">int</span> i) { i_ = i; <span class="keywordflow">return</span> *<span class="keyword">this</span>; };  <span class="comment">// returns self</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">int</span> i_;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="pondertype_8hpp.html#aee5005c7943f3506b239d987821d5486">PONDER_TYPE</a>(MyClass)</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> declare_MyClass()</div><div class="line">{</div><div class="line">    ponder::Class::declare&lt;MyClass&gt;(<span class="stringliteral">&quot;MyClass&quot;</span>)</div><div class="line">        .constructor()</div><div class="line">        .property(<span class="stringliteral">&quot;Value&quot;</span>, &amp;MyClass::Getter, &amp;MyClass::Setter);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="userobj_pointers"></a>
UserObjects can be created from user pointers</h2>
<p>UserObjects may now be created from opaque user data pointers. This was previous not possible because there was no way of casting a user pointer to a Ponder metaclass pointer. See <a href="https://github.com/billyquith/ponder/issues/30">issue #30</a>. This can now be done using the metaclass method:</p>
<div class="fragment"><div class="line">UserObject <a class="code" href="classponder_1_1_class.html#a7df3ad7b49e64e842ca2095e1d23d519">ponder::Class::getUserObjectFromPointer</a>(<span class="keywordtype">void</span> *ptr);</div></div><!-- fragment --><p>User data can be stored more efficiently like the following, only creating UserObjects when the user wishes to interact with the object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Entry {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classponder_1_1_class.html">ponder::Class</a>&amp; metaClass;</div><div class="line">    <span class="keywordtype">void</span>* p;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="remove_composed"></a>
Remove composed function bindings</h2>
<p>Ponder/CAMP previously had composed function bindings. This allowed class declarations to bind to access functions with a level of indirection. This adds a layer of complexity that can be solved in more flexible ways, for example, using lambda functions.</p>
<p>Example of a class with internal data that we would like to expose:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyClass</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Inner</div><div class="line">    {</div><div class="line">        <span class="keywordtype">void</span> f14() {}</div><div class="line">        <span class="keywordtype">void</span> f15()<span class="keyword"> const </span>{}</div><div class="line">        <span class="keywordtype">int</span> f16() {<span class="keywordflow">return</span> 16;}</div><div class="line">        <span class="keywordtype">void</span> f17(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}</div><div class="line">        <span class="keywordtype">void</span> f18() {}</div><div class="line">        <span class="keywordtype">void</span> f19() {}</div><div class="line">    };</div><div class="line"></div><div class="line">    Inner inner;</div><div class="line">    <span class="keyword">const</span> Inner&amp; getInner()<span class="keyword"> const </span>{<span class="keywordflow">return</span> inner;}</div><div class="line"></div><div class="line">    Inner* innerPtr;</div><div class="line">    <span class="keyword">const</span> Inner* getInnerPtr()<span class="keyword"> const </span>{<span class="keywordflow">return</span> innerPtr;}</div><div class="line"></div><div class="line">    std::shared_ptr&lt;Inner&gt; innerSmartPtr;</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;Inner&gt; getInnerSmartPtr() {<span class="keywordflow">return</span> innerSmartPtr;}</div><div class="line">};</div></div><!-- fragment --><p>Previously:</p>
<div class="fragment"><div class="line"><span class="comment">// declare ...</span></div><div class="line">.function(<span class="stringliteral">&quot;f14&quot;</span>, &amp;MyClass::Inner::f14, &amp;MyClass::inner)   <span class="comment">// object</span></div><div class="line">.function(<span class="stringliteral">&quot;f15&quot;</span>, &amp;MyClass::Inner::f15, &amp;MyClass::getInner) <span class="comment">// getter returning an object</span></div><div class="line">.function(<span class="stringliteral">&quot;f16&quot;</span>, &amp;MyClass::Inner::f16, &amp;MyClass::innerPtr) <span class="comment">// raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f17&quot;</span>, &amp;MyClass::Inner::f17, &amp;MyClass::getInnerPtr) <span class="comment">// getter returning a raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f18&quot;</span>, &amp;MyClass::Inner::f18, &amp;MyClass::innerSmartPtr)    <span class="comment">// smart pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f19&quot;</span>, &amp;MyClass::Inner::f19, &amp;MyClass::getInnerSmartPtr) <span class="comment">// getter returning a smart pointer</span></div><div class="line">;</div></div><!-- fragment --><p>This can now be done using lambda functions. This allows more flexibility, and extra logic may now be inserted.</p>
<div class="fragment"><div class="line"><span class="comment">// object instance</span></div><div class="line">.function(<span class="stringliteral">&quot;f14&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.inner.f14(); }))</div><div class="line"><span class="comment">// reference</span></div><div class="line">.function(<span class="stringliteral">&quot;f15&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.getInner().f15(); }))</div><div class="line"><span class="comment">// raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f16&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.innerPtr-&gt;f16(); }))</div><div class="line"><span class="comment">// getter returning a raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f17&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass <span class="keyword">const</span>&amp;)&gt;([](MyClass <span class="keyword">const</span>&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.getInnerPtr()-&gt;f17(99);</div><div class="line">          }))</div><div class="line"><span class="comment">// smart pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f18&quot;</span>, std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.innerSmartPtr.get()-&gt;f18();</div><div class="line">          }))</div><div class="line"><span class="comment">// getter returning a smart pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f19&quot;</span>, std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.getInnerSmartPtr().get()-&gt;f19();</div><div class="line">          }))</div></div><!-- fragment --><p>See unit test function.cpp for examples.</p>
<h2><a class="anchor" id="enum_type"></a>
ponder::Type now an enum class</h2>
<p>The Ponder value type enumerator was changed to a C++11 enum class. This was done for readability and to modernise the API. See <a href="https://github.com/billyquith/ponder/issues/26">issue #26</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> ValueType</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a6adf97f83acf6453d4a6a4b1070f3754">None</a>,       <span class="comment">// No type has been defined yet</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a27226c864bac7454a8504f8edb15d95b">Boolean</a>,    <span class="comment">// Boolean type (bool)</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473aa0faef0851b4294c06f2b94bb1cb2044">Integer</a>,    <span class="comment">// Integer types (unsigned/signed char short int long)</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a7f80fcc452c2f1ed2bb51b39d0864df1">Real</a>,       <span class="comment">// Real types (float, double)</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a27118326006d3829667a400ad23d5d98">String</a>,     <span class="comment">// String types (char*, std::string)</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473acf20423ed48998082c20099488a0917c">Enum</a>,       <span class="comment">// Enumerated types</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a4410ec34d9e6c1a68100ca0ce033fb17">Array</a>,      <span class="comment">// Array types (std::vector, std::list, T[])</span></div><div class="line">    <a class="code" href="namespaceponder.html#a70733c0387bfaf658c5ded607c30d473a8f9bfe9d1345237cb3b2b205864da075">User</a>        <span class="comment">// User-defined classes</span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="unittests_readded"></a>
Unit tests</h2>
<p>Some unit tests were re-added that were overlooked in the Ponder refactoring, i.e. function unit tests.</p>
<h1><a class="anchor" id="ponder_1_3"></a>
1.3 Release Notes</h1>
<p><em>date: 2016-07-06</em></p>
<h2><a class="anchor" id="id_traits"></a>
Ids/Names configurable using traits</h2>
<p>Ponder is a library which is embedded in a library and/or application. The client may have its own string type, besides <code>std::string</code>, so here we allow the customisation of the identifiers (registered names), and string types.</p>
<p>Pre-Ponder 1.3, <code>const std::string&amp;</code> was used as the parameter type for ids. The equivalent trait is:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceponder.html">ponder</a> { <span class="keyword">namespace </span>detail {</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>IdTraits</div><div class="line">    {</div><div class="line">        <span class="keyword">typedef</span> std::string         string_t;     <span class="comment">// std::string</span></div><div class="line">        <span class="keyword">typedef</span> string_t            id_value_t;   <span class="comment">// std::string</span></div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> id_value_t&amp;   id_ref_t;     <span class="comment">// const std::string&amp;</span></div><div class="line">    };</div><div class="line"></div><div class="line">}}</div></div><!-- fragment --><p>This, potentially, results in many needless string copies (see <a href="https://github.com/billyquith/ponder/issues/11">issue #11</a>). This has been replaced with a <code>string_view</code> version (see below).</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceponder.html">ponder</a> { <span class="keyword">namespace </span>detail {</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>IdTraits</div><div class="line">    {</div><div class="line">        <span class="keyword">typedef</span> std::string string_t;     <span class="comment">// std::string</span></div><div class="line">        <span class="keyword">typedef</span> string_t    id_value_t;   <span class="comment">// std::string</span></div><div class="line">        <span class="keyword">typedef</span> string_view id_ref_t;     <span class="comment">// ponder::detail::string_view</span></div><div class="line">    };</div><div class="line"></div><div class="line">}}</div></div><!-- fragment --><h2><a class="anchor" id="string_view_added"></a>
string_view class added</h2>
<p><a href="http://en.cppreference.com/w/cpp/experimental/basic_string_view"><code>string_view</code></a> is reference to a character range. It is implemented as a couple of pointers, which are more efficient to pass these around. It can be converted to a string on demand.</p>
<p>This feature is currently experimental and may not be present in all C++ standard libraries hence an internal version is provided.</p>
<p>Note, like iterators, or pointers into containers, you should not rely on the data always being there, as the string may change or be deleted.</p>
<h2><a class="anchor" id="lambda_added"></a>
Lambda functions recognised</h2>
<p>Previously lambda functions had to be declared via <code>std::function&lt;&gt;</code> wrappers. They are now disambiguated and are recognised as separate.</p>
<p>This means function declarations are a little easier to declare, e.g. :-</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyClass</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Inner</div><div class="line">    {</div><div class="line">        <span class="keywordtype">void</span> f14() {}</div><div class="line">        <span class="keywordtype">void</span> f15()<span class="keyword"> const </span>{}</div><div class="line">        <span class="keywordtype">int</span> f16() {<span class="keywordflow">return</span> 16;}</div><div class="line">        <span class="keywordtype">void</span> f17(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}</div><div class="line">        <span class="keywordtype">void</span> f18() {}</div><div class="line">        <span class="keywordtype">void</span> f19() {}</div><div class="line">    };</div><div class="line"></div><div class="line">    Inner inner;</div><div class="line">    <span class="keyword">const</span> Inner&amp; getInner()<span class="keyword"> const </span>{<span class="keywordflow">return</span> inner;}</div><div class="line"></div><div class="line">    Inner* innerPtr;</div><div class="line">    <span class="keyword">const</span> Inner* getInnerPtr()<span class="keyword"> const </span>{<span class="keywordflow">return</span> innerPtr;}</div><div class="line"></div><div class="line">    std::shared_ptr&lt;Inner&gt; innerSmartPtr;</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;Inner&gt; getInnerSmartPtr() {<span class="keywordflow">return</span> innerSmartPtr;}</div><div class="line">};</div></div><!-- fragment --><p>Previously, an example of how to wrap indirection:</p>
<div class="fragment"><div class="line"><span class="comment">// object instance</span></div><div class="line">.function(<span class="stringliteral">&quot;f14&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.inner.f14(); }))</div><div class="line"><span class="comment">// reference</span></div><div class="line">.function(<span class="stringliteral">&quot;f15&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.getInner().f15(); }))</div><div class="line"><span class="comment">// raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f16&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.innerPtr-&gt;f16(); }))</div><div class="line"><span class="comment">// getter returning a raw pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f17&quot;</span>,</div><div class="line">          std::function&lt;<span class="keywordtype">void</span>(MyClass <span class="keyword">const</span>&amp;)&gt;([](MyClass <span class="keyword">const</span>&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.getInnerPtr()-&gt;f17(99);</div><div class="line">          }))</div><div class="line"><span class="comment">// smart pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f18&quot;</span>, std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.innerSmartPtr.get()-&gt;f18();</div><div class="line">          }))</div><div class="line"><span class="comment">// getter returning a smart pointer</span></div><div class="line">.function(<span class="stringliteral">&quot;f19&quot;</span>, std::function&lt;<span class="keywordtype">void</span>(MyClass&amp;)&gt;([](MyClass&amp; <span class="keyword">self</span>){</div><div class="line">              <span class="keyword">self</span>.getInnerSmartPtr().get()-&gt;f19();</div><div class="line">          }))</div></div><!-- fragment --><p>Now:</p>
<div class="fragment"><div class="line"><span class="comment">// object instance</span></div><div class="line">.function(<span class="stringliteral">&quot;f14&quot;</span>, [](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.inner.f14(); })</div><div class="line"><span class="comment">// getter returning an object</span></div><div class="line">.<span class="keyword">function</span>(<span class="stringliteral">&quot;f15&quot;</span>, [](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.getInner().f15(); })</div><div class="line"><span class="comment">// raw pointer</span></div><div class="line">.<span class="keyword">function</span>(<span class="stringliteral">&quot;f16&quot;</span>, [](MyClass&amp; <span class="keyword">self</span>){ <span class="keywordflow">return</span> <span class="keyword">self</span>.innerPtr-&gt;f16(); })</div><div class="line"><span class="comment">// getter returning a raw pointer</span></div><div class="line">.<span class="keyword">function</span>(<span class="stringliteral">&quot;f17&quot;</span>, [](MyClass <span class="keyword">const</span>&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.getInnerPtr()-&gt;f17(99); })</div><div class="line"><span class="comment">// smart pointer</span></div><div class="line">.<span class="keyword">function</span>(<span class="stringliteral">&quot;f18&quot;</span>, [](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.innerSmartPtr.get()-&gt;f18(); })</div><div class="line"><span class="comment">// getter returning a smart pointer</span></div><div class="line">.<span class="keyword">function</span>(<span class="stringliteral">&quot;f19&quot;</span>, [](MyClass&amp; <span class="keyword">self</span>){ <span class="keyword">self</span>.getInnerSmartPtr().get()-&gt;f19(); })</div></div><!-- fragment --><h2><a class="anchor" id="auto_ptr_removed"></a>
std::auto_ptr removed</h2>
<p><code>std::auto_ptr&lt;&gt;</code> is <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr">deprecated in C++11</a> and will be fully removed in C++17. Support is removed as it generates a lot of warning spam in some compilers, GCC. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Ponder C++ library documentation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
